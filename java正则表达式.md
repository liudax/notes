# java正则表达式

> 根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。例如，当解释为正则表达式时，字符串字面值 "\b" 与单个退格字符匹配，而 "\\b" 与单词边界匹配。字符串字面值 "\(hello\)" 是非法的，将导致编译时错误；要与字符串 (hello) 匹配，必须使用字符串字面值 "\\(hello\\)"。

在其他语言中，\\ 表示：**我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。**

在 Java 中，\\ 表示：**我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。**

所以，在其他的语言中（如Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，两个 \代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\\d，而表示一个普通的反斜杠是 \\\\\\\\。



### 基础语法

#### 字符匹配

| 语法   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| \      | 将下一字符标记为特殊字符、文本、反向引用等。例如，“n"匹配字符”n“，"\n"匹配换行符。 |
| .      | 匹配除换行符以外的任意字符（\n\r）。                         |
| ^      | 匹配字符串开始的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，^ 还会与"\n"或"\r"之后的位置匹配。 |
| $      | 匹配输入字符串结尾的位置。如果设置了 **RegExp** 对象的 **Multiline** 属性，$ 还会与"\n"或"\r"之前的位置匹配。 |
| \b     | 匹配字符串结尾的地方。                                       |
| \B     | 匹配非字符串结尾的地方。                                     |
| \w     | 匹配任何字类字符，包括下划线。与"[A-Za-z0-9_]"等效。         |
| \W     | 与任何非单词字符匹配。与\[^A-Za-z0-9_]等效。                 |
| \s     | 匹配任意的空白符，包括空格、制表符、换页符等。与[\f\n\r\t\v]等效。 |
| \S     | 匹配任何非空白字符。与\[^\f\n\r\t\v]等效。                   |
| \d     | 匹配任何数字字符。与[0-9]等效。                              |
| \D     | 匹配任何非数字字符。与\[^0-9]等效。                          |
| [abc]  | 字符集，匹配包含的任一字符。例如“[abc]”匹配“apple”中的”a“。  |
| [^abc] | 反向字符集，匹配未包含的任何字符。例如“[abc]”匹配“apple”中的”p“,"l","e"。 |
| [a-z]  | 字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。可包含多个范围，如[a-zA-Z_]匹配所有大小写字母加上下划线。 |
| [^a-z] | 反向字符范围。匹配不在范围内的任何字符。                     |
| x\|y   | 匹配x或y。例如z\|food匹配z或food，(z\|f)ood匹配zood或food。  |

#### 重复限定符

| 语法  | 说明                                                         |
| ----- | ------------------------------------------------------------ |
| *     | 零次或多次匹配前面的字符或子表达式。zo*匹配“z”和"zoo"。\*与{0,}等效。 |
| +     | 一次或多次匹配前面的字符或子表达式。"zo+"与"zo"和"zoo"匹配，但与"z"不匹配。+ 等效于 {1,}。 |
| ？    | 零次或一次匹配前面的字符或子表达式。例如，"do(es)?"匹配"do"或"does"中的"do"。? 等效于 {0,1}。 |
| {n}   | *n* 是非负整数。正好匹配 *n* 次。例如，"o{2}"与"Bob"中的"o"不匹配，但与"food"中的两个"o"匹配。 |
| {n,}  | *n* 是非负整数。至少匹配 *n* 次。例如，"o{2,}"不匹配"Bob"中的"o"，而匹配"foooood"中的所有 o。"o{1,}"等效于"o+"。"o{0,}"等效于"o*"。 |
| {n,m} | *m* 和 *n* 是非负整数，其中 *n* <= *m*。匹配至少 *n* 次，至多 *m* 次。例如，"o{1,3}"匹配"fooooood"中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。 |

#### 贪婪与懒惰

|   语法   |           描述                                                   |
| ---- | ------------------------------------------------------------ |
| ?    | 当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"。 |

#### 捕获组

重复单个字符直接在字符后面加上限定符就行了，但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作。
使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组：

*  ((A)(B(C)))
*  (A)
*  (B(C))
*  (C)
还有一个特殊的组（group(0)），它总是代表整个表达式。

### JAVA程序示例

#### 基本用法

```java
Pattern pattern = Pattern.compile("\\ba\\w*\\b");
Matcher matcher = pattern.matcher("abcdab cccabcd aaacd");
int index = 0;
while (matcher.find()) {
    String res = matcher.group();
    System.out.println(index + ":" + res);
    index++;
}
```

*Pattern字段应定义为常量或者字段，因为利用好其预编译功能，可以有效加快正则匹配速度，不要在方法体内定义（阿里巴巴编码规范）。*

`\\ba\\w*\\b`表示匹配以字母a为开头的单词。
`Pattern.compile(regex)`表示将给定的正则表达式编译到具有给定标志的模式中。
`matcher(str)`创建匹配给定输入与此模式的匹配器。
`mather.find()`尝试查找与该模式匹配的输入序列的下一个子序列。
此方法从匹配器区域的开头开始，如果该方法的前一次调用成功了并且从那时开始匹配器没有被重置，则从以前匹配操作没有匹配的第一个字符开始。
如果匹配成功，则可以通过 start、end 和 group 方法获取更多信息。
`group()` 返回由以前匹配操作所匹配的输入子序列。

打印结果：
**0:abcdab**
**0:aaacd**

